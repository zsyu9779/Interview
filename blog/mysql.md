# Mysql

## 01-基础架构：一条sql语句的执行流程

以下是MySQL基本架构示意图

![](https://github.com/zsyu9779/Interview/blob/master/blog/img/mysql%20arch.png?raw=true)

### 分析一条sql语句的执行过程

```mysql
select * from T where ID=10；
```

### MySQL可以分为Server层和存储引擎层

**Server层**又包括连接器，查询缓存，分析器，优化器和执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等

**存储引擎层**负责数据的存储与提取，是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎（5.5.5版本之后默认的存储引擎是InnoDB）

#### Server层：

1.**连接器**

连接器负责跟客户端建立连接、获取权限、维持和管理连接。

连接命令一般是这么写的：

```shell
mysql -h$ip -P$port -u$user -p
```

以上命令中的mysql是客户端工具，用来跟服务端建立连接

客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。

2.**查询缓存**

连接建立完成，接下来执行select语句，执行逻辑来到第二步：查询缓存

MySql拿到一个查询请求之后，会先到查询缓存寻找之前是否执行过这条语句（若执行过，结果可能会被以key-value的形式直接缓存在内存中）如果有则直接返回给客户端，如果没有，则语句执行完成后执行结果会被存入查询缓存中

**查询缓存的弊端**：查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。**除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。**

MySQL提供了按需使用的方式：可以将参数query_cache_type设置成DEMAND，在需要使用查询缓存的时候在sql语句中显式的声明：

```mysql
select SQL_CACHE * from T where ID=10；
```

注意：MySQL 8.0版本直接将查询缓存的整块功能删掉了，8.0之后查询缓存不可用

3.**分析器**

若没有命中查询缓存，就要开始真正执行语句了

此过程中，分析器首先对语句做词法分析，根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。

4.**优化器**

开始执行前，语句还需经过优化器的处理

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：

```mysql
select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

- 既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。
- 也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。

上述执行方法的逻辑结果相同，但执行效率会有不同，优化器的作用就是选择使用哪个方案

5.**执行器**

分析，优化完成后，开始进入执行阶段

开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误

```shell
ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

比如我们[这个例子](#分析一条sql语句的执行过程)中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：

1. 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

至此，这个语句就执行完成了。

对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。



## 03-事务隔离

### 隔离性与隔离级别

ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

重点讲隔离性：

**当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。**

SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

##### 假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行两个事务的行为。

<img src="https://github.com/zsyu9779/Interview/blob/master/blog/img/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB.png?raw=true" style="zoom:30%;" />

- 若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。
- 若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。
- 若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
- 若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。

**在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。**

在“可重复读”的隔离级别下，事务开始是创建视图，整个事务存在期都在使用这个视图。 **mysql默认隔离级别**

在“读已提交”的隔离级别下，每执行一句sql创建一个视图 **oracle默认隔离级别**

“读未提交”隔离级别上直接返回记录上的最新值，“串行化”隔离级别下直接用加锁的方式避免并行访问（行锁）

**事务隔离的实现**：

事务中每个操作会有一个回滚日志，称为回滚段，要尽量避免使用长事务，防止回滚段过长占用大量的空间

### 事务启动的两种方式

- 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback
- set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。（**不建议使用，会导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。**）





## 04-深入浅出索引

### 索引的常见模型

- 哈希表
- 有序数组
- 搜索树

#### 哈希表：

哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的键即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。**哈希冲突的时候，拉出一个链表**

**缺点**：因为不是有序的，所以哈希索引做区间查询的速度很慢，所以哈希表这种结构适用于只有等值查询的场景

#### 有序数组：

按照某一字段的排序方式线性排列数据，**有序数组在等值查询和范围查询场景中的性能就都非常优秀**

按照二分法查询可快速得到，时间复杂度是O(log(N))，范围查询同理，通过二分法查找边界值，然后向左或右遍历。

**缺点**：查询效率较高，但更新数据时，若往中间插入一个数据必须挪动后面的所有记录，成本太高。因此有序数组只适用于静态存储引擎，比如你要保存的是2020年某个城市的所有人口信息，这类不会再修改的数据。

#### 搜索树：

已知平衡二叉搜索树的查询复杂度为O(log(N))，而维持平衡二叉树更新的时间复杂度也是O(log(N))，理论上可以使用平衡二叉树作为索引结构，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。

举个例子：你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间。

为了让一个查询尽量少的读磁盘，必须让查询过程访问尽量少的数据块，就应该使用N叉树，N取决于数据块的大小

**以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，即17亿**

### InnoDB的索引模型

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。

每一个索引在InnoDB中对应对应一棵B+树

假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。

这个表的建表语句是：

```mysql
create table T(
id int primary key, #默认主键索引
k int not null, 
name varchar(16),
  #自定义普通索引
index (k))engine=InnoDB;
```

表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。

<img src="https://github.com/zsyu9779/Interview/blob/master/blog/img/b-tree%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png?raw=true" style="zoom:50%;" />

- 主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。**聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引，如果还是没有的话，就采用Innodb存储引擎为每行数据内置的6字节ROWID作为聚集索引。**
- 非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。

#### **基于主键索引和普通索引的查询有什么区别？**

- 如果语句是select * from T where ID=500，即主键查询方式，则只需要搜索ID这棵B+树；
- 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

#### 覆盖索引

举个栗子🌰：

```mysql
#初始化一个表
create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

#插入数据
insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

