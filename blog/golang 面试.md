### 如何判断 2 个字符串切片（slice) 是相等的？

go 语言中可以使用反射 `reflect.DeepEqual(a, b)` 判断 a、b 两个切片是否相等，但是通常不推荐这么做，使用反射非常影响性能。

通常采用的方式如下，遍历比较切片中的每一个元素（注意处理越界的情况）。

```go

func StringSliceEqualBCE(a, b []string) bool {
    if len(a) != len(b) {
        return false
    }

    if (a == nil) != (b == nil) {
        return false
    }

    b = b[:len(a)]
    for i, v := range a {
        if v != b[i] {
            return false
        }
    }

    return true
}
```

### 字符串打印时，`%v` 和 `%+v` 的区别

`%v` 和 `%+v` 都可以用来打印 struct 的值，区别在于 `%v` 仅打印各个字段的值，`%+v` 还会打印各个字段的名称。

```go
type Stu struct {
	Name string
}

func main() {
	fmt.Printf("%v\n", Stu{"Tom"}) // {Tom}
	fmt.Printf("%+v\n", Stu{"Tom"}) // {Name:Tom}
}
```

### 空 struct{} 的用途

一般用作占位符（可以节省内存）

1.比如使用 map 表示集合时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。

2.再比如，使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。

3.声明只包含方法的结构体的时候

### init() 函数是什么时候执行的

`init()` 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。

每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 `init()` 函数。同一个包，甚至是同一个源文件可以有多个 `init()` 函数。`init()` 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 `init()` 函数的执行顺序不作保证。

一句话总结： import –> const –> var –> `init()` –> `main()`

### Go 语言的局部变量分配在栈上还是堆上？

由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。

```go
func foo() *int {
	v := 11
	return &v
}

func main() {
	m := foo()
	println(*m) // 11
}
```

foo() 函数中，如果 v 分配在栈上，foo 函数返回时，&v 就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 foo 的作用域，会将其分配在堆上。因此，main 函数中仍能够正常访问该值。

### 2 个 interface 可以比较吗？

Go 语言中，interface 的内部实现包含了 2 个字段，类型 `T` 和 值 `V`，interface 可以使用 `==` 或 `!=` 比较。2 个 interface 相等有以下 2 种情况

1. 两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）
   2）类型 T 相同，且对应的值 V 相等。

### 简述 Go 语言GC(垃圾回收)的工作原理



### 函数返回局部变量的指针是否安全？

这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。

### 内存分配器

#### 原理

内存管理一般包含用户程序，分配器，收集器三个组件（用户程序申请内存，分配器负责从堆中初始化相应的内存区域）

#### 分配方法

编程语言的内存分配器一般有两种分配方法：一种是线性分配器，一种是空闲链表分配器

##### 线性分配器

线性分配（Bump Allocator）是一种高效的内存分配方法，但是有较大的局限性。当我们使用线性分配器时，只需要在内存中维护一个指向内存特定位置的指针，如果用户程序向分配器申请内存，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置，即移动下图中的指针：

![](https://img.draveness.me/2020-02-29-15829868066435-bump-allocator.png)

虽然线性分配器实现为它带来了较快的执行速度以及较低的实现复杂度，但是线性分配器无法在内存被释放时重用内存。如下图所示，如果已经分配的内存被回收，线性分配器无法重新利用红色的内存：

![](https://img.draveness.me/2020-02-29-15829868066441-bump-allocator-reclaim-memory.png)

由于上述特性，线性分配器需要与例如标记压缩，复制算法，分代算法等配合使用

##### 空闲链表分配器

维护一个链表存储空闲内存块地址，用户程序申请内存时，遍历链表找到大小合适的内存块

由于分配内存的时候需要遍历链表，所以时间复杂度是O(n)，常见有四种策略在链表中的内存块中进行选择：

- 首次适应(First-Fit) - 从链表头开始遍历
- 循环首次适应(Next-Fit) - 从上次遍历的结束为止开始遍历，选择第一个大于申请内存的内存块
- 最优适应(Best-Fit) - 遍历寻找最合适的内存块
- 隔离适应(Segregated-Fit) - 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找满足条件的链表

**Go语言使用第四种策略**，将内存分为4、8、16、32字节的内存块组成的链表，隔离适应的策略减少了需要便利的内存块数量，提高了内存分配的效率

#### 分级分配

线程缓存分配(TCMalloc)是用于分配内存的机制，Go语言中的内存分配器借鉴了TCMalloc的设计实现高速内存分配，核心理念是使用多级缓存将对象根据大小分类，按照类别实施不同的分配策略

go运行时根据对象大小分为微对象(0~16b)，小对象[16b,32kb]和大对象(32kb,+∞)

**优点：程序中绝大多数对象大小在32kb以下，申请的内存大小影响go运行时分配内存的过程和开销，故分开处理有利于提高内存分配器的性能**

#### 多级缓存

分配器会将内存分成不同的级别分别管理：

线程缓存、中心缓存、页堆三个组件分别管理内存











